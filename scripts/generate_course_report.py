from pathlib import Path

from docx import Document
from docx.enum.style import WD_STYLE_TYPE
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.shared import Cm, Mm, Pt

OUTPUT_PATH = Path(r"c:/Users/Jack/Downloads/Kursach/Курсовая_работа_47_Сервер_погоды_final_v3.docx")

# --- документ и базовые настройки ---
doc = Document()
normal_style = doc.styles['Normal']
normal_style.font.name = 'Times New Roman'
normal_style.font.size = Pt(14)
para_fmt = normal_style.paragraph_format
para_fmt.line_spacing = 1.5
para_fmt.first_line_indent = Cm(1.25)
para_fmt.space_after = Pt(0)
para_fmt.space_before = Pt(0)

# Заголовки по методичке: TNR 18 чёрный для первого уровня, уменьшенные для вложенных
heading1 = doc.styles['Heading 1']
heading1.font.name = 'Times New Roman'
heading1.font.size = Pt(18)
heading1.font.bold = True
heading1.paragraph_format.space_after = Pt(0)
heading1.paragraph_format.space_before = Pt(12)

heading2 = doc.styles['Heading 2']
heading2.font.name = 'Times New Roman'
heading2.font.size = Pt(16)
heading2.font.bold = True
heading2.paragraph_format.space_after = Pt(0)
heading2.paragraph_format.space_before = Pt(8)

heading3 = doc.styles['Heading 3']
heading3.font.name = 'Times New Roman'
heading3.font.size = Pt(14)
heading3.font.bold = True
heading3.paragraph_format.space_after = Pt(0)
heading3.paragraph_format.space_before = Pt(6)

if '0_Рисунки' in doc.styles:
    figure_style = doc.styles['0_Рисунки']
else:
    figure_style = doc.styles.add_style('0_Рисунки', WD_STYLE_TYPE.PARAGRAPH)
    figure_style.base_style = normal_style
    figure_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER

for section in doc.sections:
    section.left_margin = Mm(30)
    section.right_margin = Mm(15)
    section.top_margin = Mm(20)
    section.bottom_margin = Mm(20)
    section.different_first_page_header_footer = True

# --- колонтитулы и нумерация (со 2-й страницы) ---
footer_para = doc.sections[0].footer.paragraphs[0]
footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
run = footer_para.add_run()
fld_char1 = OxmlElement('w:fldChar')
fld_char1.set(qn('w:fldCharType'), 'begin')
instr_text = OxmlElement('w:instrText')
instr_text.text = ' PAGE '
fld_char2 = OxmlElement('w:fldChar')
fld_char2.set(qn('w:fldCharType'), 'end')
run._r.append(fld_char1)
run._r.append(instr_text)
run._r.append(fld_char2)

first_footer = doc.sections[0].first_page_footer
first_footer.paragraphs[0].clear()

# --- вспомогательные функции ---

def add_title_line(text: str, size: int, bold: bool = True, align=WD_ALIGN_PARAGRAPH.CENTER):
    p = doc.add_paragraph()
    p.alignment = align
    r = p.add_run(text)
    r.bold = bold
    r.font.size = Pt(size)
    r.font.name = 'Times New Roman'
    return p


def add_heading(text: str, level: int):
    doc.add_heading(text, level=level)


def add_para(text: str, align=None, style: str | None = None):
    p = doc.add_paragraph(text, style=style)
    if align:
        p.alignment = align
    return p

def add_list(items):
    for it in items:
        doc.add_paragraph(it, style='List Bullet')


def add_numbered(items):
    for it in items:
        doc.add_paragraph(it, style='List Number')
def add_table(title: str, headers, rows):
    add_para(title, align=WD_ALIGN_PARAGRAPH.CENTER)
    tbl = doc.add_table(rows=1, cols=len(headers))
    hdr_cells = tbl.rows[0].cells
    for idx, h in enumerate(headers):
        hdr_cells[idx].paragraphs[0].add_run(h).bold = True
    for row in rows:
        cells = tbl.add_row().cells
        for idx, val in enumerate(row):
            cells[idx].text = val
    add_para('Таблица — ' + title, align=WD_ALIGN_PARAGRAPH.CENTER)


def add_figure_caption(number: int, caption: str):
    add_para(f"Рисунок {number} – {caption}", align=WD_ALIGN_PARAGRAPH.CENTER, style='0_Рисунки')


def add_bulk(paragraphs, repeat=1):
    for _ in range(repeat):
        for text in paragraphs:
            add_para(text)


# --- титульный лист ---
add_title_line('МИРЭА – Российский технологический университет', 14)
add_title_line('Институт информационных технологий', 14)
add_title_line('Кафедра: ________', 12, bold=False)
add_title_line('Дисциплина: Разработка серверных частей интернет-ресурсов', 12, bold=False)
add_title_line('КУРСОВАЯ РАБОТА', 18)
add_title_line('Тема №47: Серверная часть системы управления внутриигровыми погодными условиями', 12, bold=False)
add_para('')
add_title_line('Выполнил(а): ____________   Группа: ______', 12, bold=False)
add_title_line('Руководитель: ____________', 12, bold=False)
add_title_line('Москва, 2025', 12, bold=False)

doc.add_page_break()

# --- содержание ---
add_para('СОДЕРЖАНИЕ', align=WD_ALIGN_PARAGRAPH.CENTER)
contents = [
    'Перечень сокращений и обозначений',
    'Введение',
    '1 ИССЛЕДОВАТЕЛЬСКАЯ ЧАСТЬ',
    '   1.1 Анализ предметной области',
    '       1.1.1 OpenWeatherMap',
    '       1.1.2 Visual Crossing',
    '       1.1.3 Meteostat',
    '   1.2 Выбор и обоснование технологий',
    '       1.2.1 Язык программирования и фреймворк',
    '       1.2.2 Хранение данных',
    '       1.2.3 Клиентское представление и API',
    '       1.2.4 Контейнеризация и CI/CD',
    '       1.2.5 Наблюдаемость и надёжность',
    '       1.2.6 Управление рисками',
    '2 ПРОЕКТНАЯ ЧАСТЬ',
    '   2.1 Описание вариантов использования',
    '   2.2 Разработка архитектуры приложения',
    '   2.3 Модель данных системы',
    '   2.4 Разработка серверной части интернет-ресурса',
    '   2.5 Диаграммы и метрики',
    '3 ТЕХНОЛОГИЧЕСКАЯ ЧАСТЬ',
    '   3.1 Описание модулей и структур данных',
    '   3.2 Тестирование программного продукта',
    '       3.2.1 Модульное тестирование',
    '       3.2.2 Тестирование методом “черного ящика”',
    '   3.3 Безопасность и наблюдаемость',
    '   3.4 Развёртывание и CI/CD',
    '   3.5 Сопровождение и масштабирование',
    '4 ОРГАНИЗАЦИОННО-ЭКОНОМИЧЕСКАЯ ЧАСТЬ',
    'ЗАКЛЮЧЕНИЕ',
    'СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ',
    'ПРИЛОЖЕНИЕ',
]
for item in contents:
    add_para(item)

doc.add_page_break()

# --- перечень сокращений ---
add_heading('ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ', level=1)
add_list([
    'API - Application Programming Interface.',
    'REST - Representational State Transfer.',
    'HTTP - HyperText Transfer Protocol.',
    'WS - WebSocket, двунаправленный протокол.',
    'JSON - JavaScript Object Notation.',
    'DTO - Data Transfer Object.',
    'CI/CD - Continuous Integration / Continuous Delivery.',
    'DB / БД - Database / База данных.',
    'PK / FK - Primary / Foreign Key.',
    'ER-диаграмма - диаграмма сущность–связь.',
    'PoC - Proof of Concept.',
    'TLS - Transport Layer Security.',
    'RTT - Round Trip Time.',
    'SLA/SLO/SLI - Service Level Agreement / Objective / Indicator.',
    'CPU/RAM - ресурсы процессора и памяти.',
    'RTWMS - Real Time Weather Management Service.',
])

doc.add_page_break()

# --- введение ---
add_heading('ВВЕДЕНИЕ', level=1)
add_para('Современные мультиплеерные проекты опираются на погодные сценарии, которые влияют на освещение сцен, физику транспорта, поведение персонажей и экономику матчей. Любое расхождение между клиентами мгновенно замечается игроками, поэтому погодные данные должны передаваться быстро, одинаково и предсказуемо. Для этого требуется специализированный сервер, который синхронизирует погодные состояния в реальном времени и предоставляет историю прогнозов для клиентских эффектов.')
add_para('Цель работы — спроектировать и реализовать серверную часть системы управления внутриигровыми погодными условиями (RTWMS), способную генерировать, хранить и доставлять погодные данные через REST и WebSocket. Итоговый сервис должен быть разворачиваемым в контейнерах, поддерживать конфигурацию интервалов генерации, выдерживать переподключения клиентов и предоставлять интерфейс мониторинга состояния.')
add_para('Объект исследования — процесс доставки погодных данных в сетевых играх и симуляторах. Предмет исследования — архитектурные и технологические решения, которые обеспечивают низкую задержку рассылки, устойчивость к сбоям соединения и предсказуемое масштабирование при росте числа клиентов.')
add_para('В работе применяются методы анализа аналогов, проектирование архитектуры с разделением на слои контроллеров, сервисов и транспорта, выбор технологий TypeScript/Node.js и WebSocket, а также экспериментальное тестирование: модульное, интеграционное и нагрузочное. Дополнительно рассматривается контейнеризация и настройка наблюдаемости.')
add_para('Практическая ценность заключается в получении готового серверного компонента, который можно встроить в игровую инфраструктуру или обучающие симуляторы. Команда получает воспроизводимый пайплайн запуска, документированные DTO, примеры тестов и набор метрик, позволяющий контролировать качество сервиса.')
add_para('Структура отчёта повторяет методические требования: исследовательский анализ, проектные решения, технологические детали реализации, описание тестов и итоговые выводы. В приложении указываются артефакты и ссылки на репозиторий, что упрощает проверку и воспроизведение результатов.')
add_para('Дополнительно сформулированы гипотезы по оптимизации: сжатие полезной нагрузки WebSocket-сообщений, использование дельта-обновлений вместо полного состояния и адаптивная частота генерации при низкой активности. Эти идеи оцениваются по затратам и ожидаемому выигрышу в задержке доставки.')
add_para('Отдельное внимание уделено требованиям оформления: заданы поля, интервалы, начертание шрифтов и нумерация страниц согласно методическим указаниям. Документ можно использовать как эталон для защиты курсовой работы, не внося ручных правок в форматирование.')

# --- 1 Исследовательская часть ---
doc.add_page_break()
add_heading('1 ИССЛЕДОВАТЕЛЬСКАЯ ЧАСТЬ', level=1)

add_heading('Анализ предметной области', level=2)
add_para('Погодные данные в играх используются не только для визуального эффекта. Они меняют проходимость местности, баллистику, освещённость, вероятность событий и даже стратегию команд. Следовательно, сервер обязан хранить историю, публиковать прогнозы и транслировать обновления без заметных пауз. Если температура или осадки отличаются на разных клиентах, игровой процесс теряет целостность.')
add_para('Главная сложность — работа в ненадёжных сетях. Клиенты могут терять соединение, переходить между точками доступа или испытывать задержки. Поэтому сообщения должны быть короткими, а формат DTO — компактным и строго описанным. В протоколе важны таймауты, переотправки и возможность восстановить состояние сразу после reconnect.')
add_para('Требования к скорости обновлений зависят от жанра. Для шутеров и гонок обновления погоды должны укладываться в секунду, тогда как для стратегий допустим больший интервал. В любом случае сервер обязан масштабироваться по количеству WebSocket-подключений и обеспечивать предсказуемую нагрузку на сеть.')

add_heading('1.1.1 OpenWeatherMap', level=3)
add_para('OpenWeatherMap предоставляет публичное API с текущими условиями и прогнозами по городам. Сервис поддерживает разные метрики, отдаёт компактные JSON-ответы и содержит готовые географические справочники. Его преимущество — большая база станций и стабильное SLA, однако использование платных тарифов и внешняя зависимость накладывают ограничения на пиковые нагрузки.')
add_para('Интеграция удобна наличием SDK и понятной документации. Разработчик может выбирать единицы измерения и получать расширенные слои: осадки, облачность, давление, скорость ветра. Минус — необходимость учитывать квоты и предусматривать локальный кэш, чтобы игра не зависела от внешнего API.')
add_para('На Рисунке 1 представлен пример панели прогноза OpenWeather.')
add_figure_caption(1, 'Интерфейс панели OpenWeather (заменить на скриншот из проекта)')

add_heading('1.1.2 Visual Crossing', level=3)
add_para('Visual Crossing — коммерческий сервис, который помимо базовых показателей предоставляет историю, солнечную радиацию и индексы качества воздуха. Для игр это полезно, когда требуется реалистичная погодная модель со сглаженными переходами между состояниями. Поставщик предлагает CSV и JSON выгрузки, интерактивные карты и удобную фильтрацию.')
add_para('Основные достоинства — детализация прогнозов и хорошая документация. Ограничения связаны с лицензией и стоимостью запросов на больших нагрузках: при росте аудитории необходимо заранее оценить бюджет и предусмотреть fallback на локальный генератор.')
add_para('На Рисунке 2 показан интерфейс Visual Crossing.')
add_figure_caption(2, 'Интерфейс панели Visual Crossing (заменить на скриншот из проекта)')

add_heading('1.1.3 Meteostat', level=3)
add_para('Meteostat предоставляет открытые исторические данные и статистику. Наличие Python/JS клиентов позволяет автоматизировать выборки и использовать данные для обучения собственного генератора погоды. Это снижает зависимость от сторонних SLA и даёт гибкость по диапазонам значений.')
add_para('Сервис бесплатный, но не отправляет push-уведомления и требует самостоятельного кеширования. Для игрового проекта это означает дополнительную работу по агрегации, однако выгода в том, что данные можно хранить локально и не беспокоиться о тарифах.')
add_para('На Рисунке 3 представлен пример статистической панели.')
add_figure_caption(3, 'Интерфейс Meteostat (заменить на скриншот из проекта)')

add_para('Функциональные требования к RTWMS включают каталог погодных сценариев, фильтрацию по регионам, выдачу прогноза и текущих значений, а также способность работать локально при кратковременных сбоях связи. Клиенты должны получать одно и то же состояние, а сервер — хранить минимальную историю для восстановления.')
add_para('К нефункциональным требованиям относятся доставка обновлений быстрее одной секунды, масштабирование по числу WebSocket-подключений, защита от перегрузок и развёрнутая наблюдаемость. Эти пункты формируют основу критериев приёмки.')
add_para('На основании анализа составлена таблица отслеживаемости требований (Таблица 1).')
add_table(
    'Сравнительная таблица требований',
    ['Требование', 'Приоритет', 'Метрика закрытия'],
    [
        ['Доставка обновления', 'Высокий', 'P95 < 1 с'],
        ['Доступность', 'Высокий', '99.5% SLA'],
        ['Кэш прогноза', 'Средний', 'Хитрейт > 0.8'],
        ['Стабильность API', 'Высокий', 'Совместимость версий'],
    ],
)

add_heading('Выбор и обоснование технологий', level=2)
add_heading('1.2.1 Язык программирования и фреймворк', level=3)
add_para('TypeScript выбран из-за строгой типизации и привычной экосистемы Node.js. Для сетевого слоя используется Express: он минималистичен, поддерживает middleware и даёт полный контроль над маршрутизацией. WebSocket-библиотека ws добавлена для двунаправленных каналов без лишних зависимостей. Такая связка упрощает отладку и покрывается стандартными инструментами тестирования.')

add_heading('1.2.2 Хранение данных', level=3)
add_para('В прототипе данные держатся в памяти процесса: так проще достичь низкой задержки и сконцентрироваться на логике генерации. При выходе в эксплуатацию сервис может перейти на Redis для кеширования прогнозов и брокеризации событий, а исторические срезы складывать в PostgreSQL. Переход не затрагивает публичное API, потому что все DTO описаны отдельно.')

add_heading('1.2.3 Клиентское представление и API', level=3)
add_para('Клиенты используют REST методы /api/weather, /api/forecast и /api/health, а также WebSocket события initial-state и weather-update. DTO описаны в типах TypeScript, что позволяет проверять данные на этапе сборки и уменьшает вероятность рассинхронизации между фронтендом и сервером.')

add_heading('1.2.4 Контейнеризация и CI/CD', level=3)
add_para('Сборка оформлена через Dockerfile на базе node:18-alpine. Проект собирается npm скриптами, публикуется в контейнерный реестр и может подниматься через docker-compose. В конвейер CI/CD входят линт, тесты и сборка образа, что обеспечивает воспроизводимость окружения.')
add_figure_caption(4, 'Use-case диаграмма (заменить на изображение)')

add_heading('1.2.5 Наблюдаемость и надёжность', level=3)
add_para('Для мониторинга закладываются метрики (число активных клиентов, задержка доставки, частота reconnect, ошибки сериализации) и логи JSON с ключевыми полями. Наблюдаемость позволяет обнаруживать дрейф задержек или рост числа обрывов ещё до пользовательских жалоб. Дополнительно включается экспорт метрик в Prometheus и настройка алертов по SLO.')
add_para('Надёжность достигается за счёт обработки исключений в генераторе, повторной отправки состояния после reconnect и наличия health-check эндпоинта. При сбое генератора используется последнее валидное состояние, а при повторных ошибках сервис отдаёт сигнал через health, чтобы оркестратор мог перезапустить экземпляр.')

add_heading('1.2.6 Управление рисками', level=3)
add_para('Основные риски: перегрузка по WebSocket-подключениям, внешние зависимости (если использовать сторонние API), ошибки сериализации и недоступность хранилища при переходе на Redis/PostgreSQL. Для каждого риска предусмотрены меры: горизонтальное масштабирование и ограничение числа клиентов на узел; кеширование и fallback на локальный генератор; строгая валидация DTO; реплики и резервные копии для баз данных.')
add_para('Дополнительно рассматривается риск эксплуатационных ошибок: неверная конфигурация интервалов или диапазонов. Для снижения вероятности добавлены значения по умолчанию и проверка границ при запуске сервиса. Результаты анализа рисков отражены в матрице приёмки и тестовых сценариях.')

# --- 2 Проектная часть ---
doc.add_page_break()
add_heading('2 ПРОЕКТНАЯ ЧАСТЬ', level=1)

add_heading('2.1 Описание вариантов использования', level=2)
add_para('Пользовательский сценарий начинается с того, что игрок открывает веб-клиент и запрашивает текущую погоду. Клиент обращается к REST методу /api/weather, получает DTO со всеми параметрами и отображает их в интерфейсе. Одновременно запускается WebSocket-подключение, чтобы подписаться на дальнейшие обновления без повторных HTTP запросов.')
add_para('Когда клиент установил соединение, сервер отправляет событие initial-state: текущее состояние, прогноз на шесть шагов и служебный timestamp. Далее приходят события weather-update с новой выборкой. Если соединение рвётся, клиент переподключается и запрашивает актуальное состояние, не теряя контекст.')
add_para('Оператор эксплуатации использует маршрут /api/health для проверки живости сервиса, числа активных подписчиков и задержки генерации. Это позволяет обнаруживать деградацию до того, как она затронет игроков.')
add_para('Администратор может менять интервалы генерации или диапазоны параметров через конфигурацию и перезапуск сервиса. Игровые сервера запрашивают прогноз, чтобы заранее подгрузить эффекты и синхронизировать физику. Диаграмма вариантов использования показана на Рисунке 5.')
add_figure_caption(5, 'Диаграмма вариантов использования RTWMS (заменить на рисунок)')

add_heading('2.2 Разработка архитектуры приложения', level=2)
add_para('Архитектура разделена на четыре уровня. Контроллеры принимают HTTP-запросы, валидируют параметры и переводят их в сервисные вызовы. Сервисный слой агрегирует текущее состояние и прогноз, управляет кешем и подготавливает DTO для клиентов. Генератор отвечает за вычисление новых значений погодных параметров с учётом случайности и заданных диапазонов. Транспорт WebSocket занимается подписками, ping/pong и широковещательной рассылкой обновлений.')
add_para('Конфигурация вынесена в config/default.ts: здесь определяются интервалы генерации, порты, диапазоны значений и опции логирования. Такая изоляция позволяет изменять параметры без переписывания бизнес-логики. Взаимодействие слоёв и внешних клиентов показано на диаграмме компонентов (Рисунок 6).')
add_para('При ошибках сериализации или невалидных данных контроллеры возвращают детализированные сообщения и коды 400/422, а сервис фиксирует событие в логах. Если WebSocket-клиент отправляет неподдерживаемый тип сообщения, соединение закрывается с понятной причиной. Это упрощает диагностику во время эксплуатации.')
add_para('Внутренние модули не зависят от конкретного транспорта: генератор и сервисы можно переиспользовать для gRPC или MQTT при необходимости. Такая модульность снижает стоимость будущих интеграций с другими типами клиентов, например, мобильными приложениями или цифровыми табло.')
add_figure_caption(6, 'Диаграмма компонентов RTWMS (заменить на рисунок)')

add_heading('2.3 Модель данных системы', level=2)
add_para('Сущность Weather хранит тип погоды, температуру, влажность, скорость ветра, видимость, давление и временную метку. Каждый прогноз представляет собой массив из шести объектов Weather, что позволяет клиенту заранее подготовить эффекты и расчёты. При необходимости модель можно расширить новыми полями (например, UV-индекс или количество осадков), не ломая обратную совместимость DTO.')
add_table(
    'Модель Weather',
    ['Поле', 'Тип', 'Диапазон'],
    [
        ['type', 'string', 'sunny | rainy | snowy | foggy | stormy'],
        ['temperature', 'number', '-50 .. +50'],
        ['humidity', 'number', '0 .. 100'],
        ['windSpeed', 'number', '0 .. 40'],
        ['visibility', 'number', '100 .. 10000'],
        ['pressure', 'number', '980 .. 1030'],
    ],
)
add_para('ER-диаграмма отражает связь прогнозов, текущего состояния и истории измерений (Рисунок 7). Ключевые атрибуты выделены типами и диапазонами, что облегчает валидацию на стороне сервера и клиента. Для обратной совместимости добавлено правило: новые поля должны иметь значения по умолчанию, иначе старые клиенты не смогут обработать ответ.')
add_figure_caption(7, 'ER-диаграмма хранения погодных данных (заменить на рисунок)')

add_heading('2.4 Разработка серверной части интернет-ресурса', level=2)
add_para('Сервер написан на TypeScript: контроллеры принимают запросы, вызывают сервисы и формируют HTTP ответы. Сервисный слой хранит последнее состояние, формирует прогноз и обновляет его по таймеру. Генератор использует фиксированные диапазоны и seed для воспроизводимости, что важно при тестировании и повторном запуске.')
add_para('WebSocket-транспорт обрабатывает подключение, отправляет initial-state и принимает ping/pong для контроля активности. При обновлении состояния сервис широковещательно рассылает событие weather-update всем подписанным клиентам. Для иллюстрации работы подготовлены две последовательности: загрузка прогноза и подключение клиента (Рисунки 8–9).')
add_para('Планировщик генерации запускается по интервалу и защищён от повторного входа: если вычисление заняло дольше периода, следующий запуск ждёт завершения, чтобы не допустить гонок. В случае исключения генератора сервис логирует проблему, отдаёт предыдущее состояние и выставляет флаг деградации в метриках health-check.')
add_para('Для клиентов с медленным подключением предусмотрен буфер: если отправка сообщения занимает слишком долго, соединение закрывается с кодом политики, чтобы не задерживать остальных подписчиков. Это важная мера для поддержания стабильной задержки в пиковые моменты.')
add_figure_caption(8, 'Сценарий “Загрузка прогноза” (заменить на рисунок)')
add_figure_caption(9, 'Сценарий “Подключение клиента по WS” (заменить на рисунок)')

add_heading('2.5 Диаграммы и метрики', level=2)
add_table(
    'Целевые метрики производительности',
    ['Показатель', 'Цель', 'Комментарий'],
    [
        ['REST P95', '<150 мс', 'Внутри датацентра'],
        ['WS задержка', '<1 с', '5k клиентов'],
        ['Доступность', '99.5%+', 'Ежемесячно'],
        ['Хитрейт кэша', '>0.8', 'Прогнозы'],
    ],
)
add_para('Наблюдаемость включает логи JSON с ключевыми полями (тип события, идентификатор клиента, длительность операции), метрики Prometheus (активные клиенты, задержка, ошибки сериализации) и выборочные трассировки проблемных сценариев. Метрики позволяют быстро заметить рост задержек или увеличение числа разрывов соединения.')
add_figure_caption(10, 'Гистограмма задержек обновлений (заменить на рисунок)')

# --- 3 Технологическая часть ---
doc.add_page_break()
add_heading('3 ТЕХНОЛОГИЧЕСКАЯ ЧАСТЬ', level=1)

add_heading('3.1 Описание модулей и структур данных', level=2)
add_para('В файле app.ts настраиваются middleware, CORS и маршруты REST. Он подключает контроллеры и передаёт им зависимости. Файл server.ts создаёт HTTP-сервер, подключает WebSocket и запускает расписание обновлений погоды.')
add_para('Модуль weatherGenerator.ts отвечает за генерацию текущего состояния и прогноза. Он учитывает допустимые диапазоны и интервал обновления. Сервис weatherService.ts хранит последнее состояние и приводит его к DTO перед отправкой.')
add_para('syncService.ts управляет подписками, контролирует список активных клиентов и рассылает обновления. Транспорт ws.ts инкапсулирует работу с WebSocket: хэндшейк, ping/pong и сериализацию сообщений. Структура проекта показана на Рисунке 11, а фрагмент сервиса — на Рисунке 12.')
add_figure_caption(11, 'Структура проекта RTWMS (заменить на рисунок)')
add_figure_caption(12, 'Фрагмент weatherService.ts (заменить на скриншот)')

add_heading('3.2 Тестирование программного продукта', level=2)
add_heading('3.2.1 Модульное тестирование', level=3)
add_para('Модульные тесты проверяют генератор: каждое поле (температура, влажность, ветер) остаётся в допустимых границах, прогноз содержит шесть точек, а DTO строго соответствует типам. Отдельные тесты проверяют обработку пограничных значений и воспроизводимость генерации при фиксированном seed.')
add_heading('3.2.2 Тестирование методом “черного ящика”', level=3)
add_para('Для проверки внешнего поведения используется метод “черного ящика”. Клиент посылает запрос /api/weather и ожидает 200 OK с корректным телом. Затем подключается к WebSocket, получает initial-state и отслеживает, что обновления приходят с заявленным интервалом. Отдельно проверяется сценарий обрыва соединения: после reconnect клиент снова получает актуальное состояние.')
add_para('На Рисунках 13–14 представлены примеры тестов и их результаты.')
add_figure_caption(13, 'Пример модульных тестов (заменить на скриншот)')
add_figure_caption(14, 'Пройденные тесты в отчёте (заменить на скриншот)')

add_heading('3.2.3 Нагрузочное тестирование', level=3)
add_para('Нагрузочные испытания моделируют 1k, 5k и 10k WebSocket-подключений с интервалом обновлений 5 секунд. Инструменты собирают среднюю и 95-процентильную задержку доставки, фиксируют количество повторных подключений и ошибки сериализации. После теста логи анализируются на предмет таймаутов и медленных клиентов.')
add_para('Рисунок 15 демонстрирует экран мониторинга нагрузки, а Рисунок 16 — страницу прогноза в клиентском интерфейсе под нагрузкой.')
add_figure_caption(15, 'Главная панель мониторинга погоды (заменить на скриншот)')
add_figure_caption(16, 'Страница прогноза/истории (заменить на скриншот)')

add_heading('3.3 Безопасность и наблюдаемость', level=2)
add_para('Безопасность включает валидацию входных параметров, ограничение частоты запросов для REST и handshake WebSocket, а также разделение ролей: операторы получают доступ к /api/health, игроки — только к погодным данным. Для публичных развёртываний рекомендуется вынести TLS-терминацию на балансировщик и включить проверку Origin для WebSocket.')
add_para('Наблюдаемость опирается на метрики и логи. Метрики публикуются в формате Prometheus и охватывают задержку доставки, число клиентов, ошибки сериализации и частоту reconnect. Логи JSON позволяют быстро фильтровать события по пользователю или типу ошибки. При подозрении на деградацию включается трассировка отдельных запросов, чтобы найти узкие места.')

add_heading('3.4 Развёртывание и CI/CD', level=2)
add_para('Сборка выполняется командой npm run build, после чего создаётся Docker-образ на базе node:18-alpine. В CI пайплайне выполняются линт и тесты, затем собирается и публикуется образ. Для развёртывания достаточно docker-compose up либо kubectl apply с манифестами, в которых задаются переменные окружения и ограничение ресурсов.')
add_para('Перед выкатыванием на production рекомендуется прогонять smoke-тесты: запрос /api/health, одно подключение к WebSocket и проверка события weather-update. Для отката используется предыдущий тег образа. В документации описан чек-лист запуска и переменные окружения (PORT, WEATHER_UPDATE_INTERVAL, FORECAST_DAYS, LOG_LEVEL).')

add_heading('3.5 Сопровождение и масштабирование', level=2)
add_para('План сопровождения предполагает регулярные обновления зависимостей, проверку уязвимостей npm audit и ревизию конфигурации каждые спринты. Масштабирование достигается горизонтальным тиражированием экземпляров: клиенты балансируются по WebSocket через общий входной балансировщик, состояние не хранится в памяти между узлами, поэтому подключение к любому инстансу эквивалентно.')
add_para('Для высоких нагрузок можно вынести генератор в отдельный процесс и публиковать события через Redis Pub/Sub. Это разгрузит узлы WebSocket и позволит разделить ответственность: один сервис генерирует прогнозы, другие рассылают их клиентам. Дополнительно вводятся лимиты на число клиентов на узел и автоматическое масштабирование по метрикам задержки и CPU.')

# --- 4 Организационно-экономическая часть ---
doc.add_page_break()
add_heading('4 ОРГАНИЗАЦИОННО-ЭКОНОМИЧЕСКАЯ ЧАСТЬ', level=1)
add_para('Трудозатраты оцениваются в 220–240 часов: исследование и сбор требований — 40 часов; проектирование архитектуры и моделирование данных — 60 часов; разработка и покрытие тестами — 90 часов; документирование и подготовка артефактов — 30–40 часов. Оценка учитывает ревью и доработки по замечаниям.')
add_para('Инфраструктурные затраты минимальны: используется бесплатный стек (Node.js, TypeScript, ws, Jest), развёртывание возможно на одном узле или в контейнерах. При росте нагрузки добавляется Redis для Pub/Sub и кэширования, а также выделенный балансировщик для WebSocket. Эти элементы можно арендовать как управляемые сервисы, что снижает операционные риски.')
add_para('Экономический эффект выражается в сокращении времени интеграции погодного сервиса в игры и симуляторы: готовый REST/WS API и документация уменьшают время на разработку собственного решения и тестирование. Дополнительная выгода — предсказуемость поведения клиентов благодаря единым DTO и тестовым сценариям.')
add_para('Риски затрат включают перерасход времени на нагрузочное тестирование и возможное удорожание лицензий, если будет задействовано внешнее погодное API. Эти риски нивелируются ранним прототипированием, чёткими лимитами на число клиентов и наличием fallback на локальный генератор. Итоговый бюджет на эксплуатацию оценивается как линейный по числу узлов и клиентов.')

# --- Заключение ---
doc.add_page_break()
add_heading('ЗАКЛЮЧЕНИЕ', level=1)
add_para('В ходе работы разработан прототип серверной части RTWMS, способный выдавать текущую погоду и прогноз через REST и WebSocket. Сервис обеспечивает синхронизацию состояния между множеством клиентов и поддерживает восстановление после обрыва соединений.')
add_para('Архитектура разделена на контроллеры, сервисы, генератор и транспортный слой, что облегчает сопровождение и даёт возможность точечно масштабировать компоненты. Конфигурация вынесена в отдельный модуль, поэтому изменить интервалы или диапазоны можно без правок кода.')
add_para('Выполнены модульные, интеграционные и нагрузочные испытания. Получены метрики задержек и стабильности, определены критерии приёмки и сценарии деградации. Наблюдаемость оформлена через логи и метрики, что позволяет быстро реагировать на инциденты.')
add_para('Дальнейшее развитие включает поддержку регионов, кэширование прогнозов в Redis, расширенные метрики и автоматическое масштабирование по числу WebSocket-сессий. Также полезно добавить авторизацию и ограничение частоты запросов для публичных развертываний.')

# --- Список источников ---
doc.add_page_break()
add_heading('СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ', level=1)
refs = [
    '1. Fielding R. Architectural Styles and the Design of Network-based Software Architectures, 2000.',
    '2. Fowler M. Patterns of Enterprise Application Architecture. Addison-Wesley, 2003.',
    '3. Evans E. Domain-Driven Design. Addison-Wesley, 2004.',
    '4. Kleppmann M. Designing Data-Intensive Applications. O’Reilly, 2017.',
    '5. RFC 6455 – The WebSocket Protocol, IETF.',
    '6. RFC 7231 – HTTP/1.1 Semantics and Content.',
    '7. Node.js Documentation, 2024.',
    '8. TypeScript Handbook, 2024.',
    '9. Express.js Guide, 2024.',
    '10. ws WebSocket Library Docs, 2024.',
    '11. Docker Documentation, 2024.',
    '12. Jest Official Docs, 2024.',
    '13. OpenWeatherMap API Docs, 2024.',
    '14. Visual Crossing Weather API Docs, 2024.',
    '15. Meteostat Documentation, 2024.',
    '16. OWASP Cheat Sheet Series – WebSocket Security, 2023.',
    '17. Microsoft. REST API Design Guidelines, 2023.',
    '18. Prometheus Documentation, 2024.',
    '19. Redis Pub/Sub Documentation, 2024.',
    '20. ISO/IEC 25010:2011 Systems and software Quality Models.',
    '21. ISO/IEC 27002:2022 Information security controls.',
    '22. Martin R., Clean Architecture, 2017.',
]
add_bulk(refs, repeat=1)

# --- Приложение ---
doc.add_page_break()
add_heading('ПРИЛОЖЕНИЕ', level=1)
add_para('Репозиторий прототипа: https://github.com/PzKpfw-ausf-H/realtime-weather-server. В нём размещён исходный код, Dockerfile и примеры конфигурации. Для быстрого старта достаточно выполнить npm install, npm run build и запустить контейнер с указанными переменными окружения.')
add_para('В README.md описаны требования к окружению, структура каталогов и команды для локального и контейнерного запуска. Там же приведены примеры запросов к REST и WebSocket, что облегчает проверку работоспособности без дополнительного инструментария.')

# --- сохранение ---
OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
doc.save(OUTPUT_PATH)
print(f'Report generated: {OUTPUT_PATH}')
